{"version":3,"sources":["webpack:///10.blog.js","webpack:///../posts/2015_03_01_True-isomorphic-apps-with-React-and-Baobab.md"],"names":["webpackJsonp",344,"module","exports"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,QAAA","file":"10.blog.js","sourcesContent":["webpackJsonp([10],{\n\n/***/ 344:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"# True isomorphic apps with React and Baobab\\n\\nSo this little library Baobab continues to surprise me. The [previous article](http://christianalfoni.github.io/javascript/2015/02/06/plant-a-baobab-tree-in-your-flux-application.html) I wrote on this used a strategy where you would lock up all your components, but have a dependency to the state tree of the application in each component that needed it. The individual components could point cursors into the state tree, allowing the component to extract state from the state tree and render itself whenever the cursor notified about a change. This optimized the rendering of React JS and gave a very good FLUX structure to your application.\\n\\nWhen going isomorphic though... wait, let me explain what an isomorphic app is before we move on. Typically with a single page application you pass only som basic HTML and script tags on the initial page request. When the page and scripts load, your application starts. You probably have a loader indicating the scripts loading, or if not, just a white screen. This might not seem like such a big problem, but it is. Visitors on your page or application really does not like waiting, not even for a few hundred milliseconds. The google bot collecting page information does not like this either. It requires a complete HTML page to be served when hitting your URL.\\n\\nSo, when going isomorphic, you will actually render your application on the server and deliver it along with your base HTML and script tags. That way the user will instantly see content. React JS is especially elegant in handling this because it will piggy back the existing HTML. What I mean is that when React JS has loaded and you render your application again on the client it will notice that the existing HTML on the page is rendered by React on the server. So instead of doing a normal render, it will just register event listeners etc.\\n\\n### Why change Baobab strategy?\\nWhen loading the application components on the server it will load all the dependencies of each component also. If you are depending on business logic, like some module that changes the state of the tree, that module will probably have its dependencies too. What you end up with is loading your whole client side application on the server, when you only wanted to load the components. This could get you into trouble. There is also a matter of trying to find a way to isolate components to a level where they really are just components.\\n\\n### The current injecting possibilities with React\\nThere are two strategies to injecting state into your application. The first one is using props and the other is using context.\\n\\n#### Props\\n```javascript\\n\\nvar Baobab = require('baobab');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\nvar AppComponent = React.createClass({\\n  render: function () {\\n    return (\\n      <h1>Hello app, you have {this.props.store.items.length} left</h1>\\n    );\\n  }\\n});\\n\\nvar render = function () {\\n  React.render(<AppComponent store={store.get()})/>, document.body);\\n};\\nstore.on('update', render);\\n```\\n\\nOkay, so now we are passing the complete store down to our components and whenever the tree changes, we pass it down again. Since the store shifts references up the tree when a change is done, we can safely use the **PureRenderMixin** on our components. But we have a problem.\\n\\nImagine all the sub components that makes up your app. Most of them will need access to this store object. They can only get that access if their parent passes it down. This pretty much means that all your components has to pass a **store** prop down to its children. That is a lot of work and it couples your components, which is not ideal.\\n\\n#### Context\\nA different strategy is using something called a context. Now, this is not very well documented, but good research is done with [this article](https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html). **withContext** is deprecated in favor of using **getChildContext**. Lets have a look at that:\\n\\n```javascript\\n\\nvar Baobab = require('baobab');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\n\\nvar AppComponent = React.createClass({\\n  contextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  render: function () {\\n    return (\\n      <h1>Hello app, you have {this.context.store.items.length} left</h1>\\n    );\\n  }\\n});\\n\\nvar render = function () {\\n  React.render(<WrapperComponent store={store.get()})/>, document.render);\\n};\\nstore.on('update', render);\\n```\\n\\nAs you can see we use a wrapper that sets a context for the application. Any sub component, regardless of their parent, can use the **contextTypes** property and extract the store. That is great! We have removed the need to pass the store down as properties. But we have a problem.\\n\\nIn the [Q&A at react-conf 2015](https://www.youtube.com/watch?v=EPpkboSKvPI&index=20&list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr), around 09:00, there is a question about context. The answer does not flesh out exactly why it is a bad idea, but I think I know why. The problem is two fold, but they are both related to using PureRenderMixin.\\n\\n1. The PureRenderMixin does not check if the values on the context object has changed, making it unable to verify that a render is necessary\\n2. A parent component might not be using the context, but the child does. If the parent uses PureRenderMixin it will not render the child when the context updates\\n\\nA third challenge to mention here, which exists both using **props** and **context**, is that we loose the possbility to just render components that actually needs to update. The store is injected from the top on every change.\\n\\n### So can we get the best of both worlds?\\nI will go through this section showing how this works on the client and server in parallell. Lets get going.\\n\\n#### The injected state\\nWe will not inject the state the same way on the client and the server. On the client we will inject the Baobab tree itself, but on the server we will just inject a plain object. Lets see it in action:\\n\\n*client*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\nvar WrapperComponent = require('./AppWrapper.js');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\n// As you can see we are not using store.get(), but passing the actual store\\nReact.render(<WrapperComponent store={store})/>, document.render);\\n```\\n\\n*server*\\n```javascript\\n\\nvar React = require('react');\\nvar WrapperComponent = require('./app/AppWrapper.js');\\n\\n// We just create a normal object and inject that\\nvar store = {\\n  items: []\\n};\\n\\n// We will see later what we will do with this html\\nvar html = React.renderToString(<WrapperComponent store={store})/>);\\n```\\n\\n#### How the wrapper exposes the context\\nNow, this works exactly the same on the server and client.\\n\\n*WrapperComponent.js*\\n```javascript\\n\\nvar React = require('react');\\nvar AppComponent = require('./AppComponent.js');\\n\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\nmodule.exports = WrapperComponent;\\n```\\n\\nThe wrapper component will expose either the Baobab state tree itself or just a plain object, depending on it being the client or the server.\\n\\n#### A mixin to extract state\\nAs we know from the [existing mixins](https://github.com/Yomguithereal/baobab#react-mixins) for Baobab it is possible to extract state by using a cursors object defined on the component itself. Since we are using the Baobab state tree a bit differently here, we have to create a new mixin. I actually created a [pull request](https://github.com/Yomguithereal/baobab/pull/107) for this. It ended up in a discussion that brings up a different approach. It uses an application event hub to decouple business logic from the components. I encourage you to check it out! But now lets see how we use the mixin on a component\\n\\n*SomeComponent.js (client and server)*\\n```javascript\\n\\nvar React = require('react');\\nvar ContextMixin = require('./ContextMixin.js');\\n\\nvar SomeComponent = React.createClass({\\n  mixins: [ContextMixin],\\n  cursors: {\\n    list: ['admin', 'list']\\n  },\\n  render: function () {\\n  \\n    // Notice we point to the state and not the context\\n    return (\\n      <h1>There are {this.state.list.length} items in this list</h1>\\n    );\\n  }\\n});\\nmodule.exports = SomeComponent;\\n```\\n\\nThe only thing we depend on is the mixin. As the state tree is injected into the context of our application there is no direct dependency to it. The mixin will move the value from the context to the state of the component to allow PureRenderMixin to do its work.\\n\\nAnd now how the mixin actually works:\\n\\n*ContextMixin.js*\\n```javascript\\n\\nvar React = require('react/addons');\\n\\n// We have to know if we are on the client or the server\\nvar isBrowser = !(global && Object.prototype.toString.call(global.process) === '[object process]');\\n\\nvar ContextMixin = {\\n  \\n  // We add the PureRenderMixin for optimized rendering\\n  mixins: [React.addons.PureRenderMixin],\\n  \\n  // We grab the store from the context\\n  contextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  componentWillMount: function () {\\n\\n    if (!this.context || !this.context.store) {\\n      throw new Error('You have to pass a store to you app wrapper');\\n    }\\n    \\n    // If no cursors present, just return\\n    if (!this.cursors) {\\n      return;\\n    }\\n\\n    // Prepare a map of listeners to\\n    // state update\\n    this.subscriptions = {};\\n    \\n    // This is where we create subscriptions to cursors so that\\n    // the component knows about changes\\n    var component = this;\\n    var createSubscription = function (key, cursor) {\\n      return function (value) {\\n        var state = {};\\n        state[key] = cursor.get();\\n        component.setState(state);\\n      };\\n    };\\n\\n    // We go through the cursors\\n    var state = {};\\n    Object.keys(this.cursors).forEach(function (cursorKey) {\\n\\n      // If we are in the browser we move the current state of the\\n      // cursor over to the state object, using the key defined on\\n      // the cursor as the key on our state object. We also register\\n      // a listener for state changes\\n      if (isBrowser) {\\n\\n        var cursor = this.context.store.select(this.cursors[cursorKey]);\\n        var callback = createSubscription(cursorKey, cursor)\\n        state[cursorKey] = cursor.get();\\n        this.subscriptions[cursorKey] = {\\n          cursor: cursor,\\n          callback: callback\\n        };\\n        cursor.on('update', callback);\\n\\n      // If we are on the server we use the same cursor path defined.\\n      // But instead of using the Baobab API, we use the path to drill \\n      // into the state object and set the state\\n      } else {\\n\\n        var path = this.cursors[cursorKey];\\n        var value = path.reduce(function (contextPath, pathKey, index) {\\n          return contextPath[pathKey];\\n        }, this.context.store);\\n        state[cursorKey] = value;\\n\\n      }\\n\\n    }, this);\\n    \\n    // Then we actually put that state on the component\\n    this.setState(state);\\n\\n  },\\n  \\n  // Unregisters listeners of state change\\n  componentWillUnmount: function () {\\n    Object.keys(this.subscriptions).forEach(function (subscription) {\\n      this.subscriptions[subscription].cursor.off('update', subscription.callback);\\n    }, this);\\n  }\\n};\\nmodule.exports = ContextMixin;\\n```\\n\\n### The complete flow\\nNow let us take a look at the complete flow from server to client. We are going to use the jsx file extension as we want to use components on the server too. The benefit of using the jsx extension is that node will only transpile jsx files, not normal js files. Let us first look at the index.html file that we want to load up:\\n\\n*index.html*\\n```javascript\\n\\n<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\\"UTF-8\\\"/>\\n  </head>\\n  <body>\\n    {{APP}}\\n    <script>\\n      window.store = {{STORE}}\\n    </script>\\n    <script src=\\\"app.js\\\"></script>\\n  </body>\\n</html>\\n```\\n\\nWe create a placeholder for where we want to put the HTML of our app. We also put the state we created on the global window object. This allows our client store to grab that state and that way being in sync. We will see this soon.\\n\\n*server.js*\\n```javascript\\n\\n// We make jsx syntax available to node\\nrequire('node-jsx').install({extension: '.jsx'})\\n\\nvar express = require('express');\\nvar fs = require('fs');\\nvar path = require('path');\\nvar React = require('react');\\n\\n// We use a factory as our main server file does not support JSX, \\n// only required files\\nvar AppWrapper = React.createFactory(require('./app/AppWrapper.jsx'));\\n\\n// We fire up an express server\\nvar app = express();\\n\\n// We read the contents of an HTML file we have\\nvar index = fs.readFileSync(path.resolve(__dirname, 'index.html')).toString();\\n\\napp.get('/', function (req, res) {\\n\\n  // First we build up the contents of the store. This could be \\n  // fetching database stuff or whatever\\n  buildStoreContent()\\n    .then(function (store) {\\n    \\n      // We render the application to an HTML string, passing in the store\\n      var app = React.renderToString(AppWrapper({store: store}));\\n      \\n      // We replace our placeholders with both the app html itself and the \\n      // state of the store. You might prefer loading the store state with \\n      // ajax after initial page load in case it is quite large. It is a \\n      // balance you have to decide\\n      var html = index\\n        .replace('{{APP}}', app)\\n        .replace('{{STORE}}', JSON.stringify(store));\\n      \\n      res.type('html');\\n      res.send(html);\\n    });\\n\\n});\\napp.listen(3000);\\n```\\n\\nSo when our client now goes to `localhost:3000` the HTML responded will have the HTML of our app and a store object containing the state it was based upon. The browser will also load up `app.js`. This is a bundled file using either browserify or webpack, so let us look at the main entry file:\\n\\n*main.js (entry point bundled into app.js)*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\n\\n// Coponent uses our ContextMixin\\nvar WrapperComponent = require('./app/WrapperComponent.jsx');\\n\\n// We grab the state from the window\\nvar store = new Baobab(window.store, {\\n  shiftReferences: true\\n});\\n\\nReact.render(<WrapperComponent store={store}/>, document.render);\\n```\\n\\nSo when our `app.js` file launches it will do the exact same thing as the server did, only with a Baobab store instead. The beauty of it is that React JS understands that the current HTML is part of the application. It will basically just wire up the listeners to the store, and do updates when the store has a change. The really cool thing about this is that the components listens to the store completely decoupled from their parent components. This means that the rendering of the application is still as optimized as the strategy explained in the previous article.\\n\\n### Changing the state of the store with actions\\nBut how do we actually go about changing the state of our store from within the components? It would not be a good idea to give each component a dependency to the store, as that is actually what we wanted to avoid. Well, why not use the context? Actions will never be triggered on the server side. They are triggered when the user interacts with the application or some other client module interacts with the store, maybe a websocket service. So how would we do this? Let us extend our wrapper and mixin to also handle actions:\\n\\n*WrapperComponent.jsx*\\n```javascript\\n\\nvar React = require('react');\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object,\\n    actions: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store,\\n      actions: this.props.actions\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\nmodule.exports = WrapperComponent;\\n```\\n\\n\\n*ContextMixin*\\n```javascript\\n\\nvar React = require('react/addons');\\nvar isBrowser = !(global && Object.prototype.toString.call(global.process) === '[object process]');\\n\\nvar ContextMixin = {\\n  mixins: [React.addons.PureRenderMixin],\\n  \\n  // Adding actions\\n  contextTypes: {\\n    store: React.PropTypes.object,\\n    actions: React.PropTypes.actions\\n  },\\n  componentWillMount: function () {\\n\\n    if (!this.context || !this.context.store) {\\n      throw new Error('You have to pass a store to you app wrapper');\\n    }\\n    \\n    // We reference the actions on the component itself, to\\n    // shorten the syntax. this.actions, instead of this.context.actions\\n    this.actions = this.context.actions;\\n    \\n    // ... rest of mixin\\n\\n  },\\n  componentWillUnmount: function () { ... }\\n};\\nmodule.exports = ContextMixin;\\n```\\n\\nOkay, so now we are able to pass actions down through our components. We do not have to do any changes on the server, as actions will not be triggered there. But let us pass some actions on our client, looking at our entry point file again:\\n\\n*main.js (entry point bundled into app.js)*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\nvar WrapperComponent = require('./WrapperComponent.jsx');\\n\\n// Just looking at window.store\\nwindow.store; // { list: [] }\\n\\n// We grab the state from the window\\nvar store = new Baobab(window.store, {\\n  shiftReferences: true\\n});\\n\\n// We create an action to update the store\\nvar actions = {\\n  addItem: function (item) {\\n    store.select('list').push(item);\\n  }\\n};\\n\\n// And we pass those actions down\\nReact.render(<WrapperComponent store={store} actions={actions}/>, document.render);\\n```\\n\\nSo inside our **WrapperComponent** somewhere we have a component that wants to trigger our **addItem** action. Lets imagine:\\n\\n*ListComponent.jsx*\\n```javascript\\n\\nvar React = require('react/addons');\\nvar ContextMixin = require('./ContextMixin.js');\\n\\nvar ListComponent = React.createClass({\\n  mixins: [ContextMixin, React.addons.LinkedStateMixin],\\n  cursors: {\\n  \\n    // We grab the list from the store and put as \\\"list\\\"\\n    // on the components state object. We also listen to\\n    // any changes to this list value\\n    list: ['list']\\n  },\\n  \\n  // We return an initial state for our input that\\n  // will be the interaction of adding a new item to\\n  // the list\\n  getInitialState: function () {\\n    return {\\n      title: ''\\n    };\\n  },\\n  \\n  // We just point to this.actions and run\\n  // the method\\n  addItem: function () {\\n    this.actions.addItem(this.state.title);\\n    this.setState({\\n      title: ''\\n    });\\n  },\\n  renderItem: function (item) {\\n    return <li>{item}</li>\\n  },\\n  render: function () {\\n    return (\\n      <div>\\n        <form onSubmit={this.addItem}>\\n          <input valueLink={this.linkState('title')}/>\\n        </form>\\n        <ul>\\n          {this.state.list.map(this.renderItem)}\\n        </ul>\\n      </div>\\n    );\\n  }\\n});\\n\\nmodule.exports = ListComponent;\\n```\\n\\nAs we can see, using the mixin, we can point to actions on the component itself. This rather than `this.context.actions`. If your application has a lot of actions you could namespace them `this.actions.todos.add`, `this.actions.notifications.fetch` etc.\\n\\n### Summary\\nIn my opinion this is exactly how I want to build my apps. I want to inject state on the server and render the application there, but still allow for highly optimized rendering on the client. I want my components to be as pure as possible and depend on as little as possible. Everything components needs to know about, they know through the context they are running in. \\n\\nI have used this technique on a project I am working on called [EmptyBox](https://github.com/christianalfoni/EmptyBox). It is a hackable blog service using React JS. It also has some other cool features you can not achieve without React JS.\\n\\nTo see a more simple example using this technique you can check out [this repo](https://github.com/christianalfoni/isomorphic-react-baobab-example).\\n\\nPlease feel free to use the mixin documented here or check out the alternative strategy explained in the [pull request](https://github.com/Yomguithereal/baobab/pull/107). Thanks for reading!\\n\"\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** 10.blog.js\n **/","module.exports = \"# True isomorphic apps with React and Baobab\\n\\nSo this little library Baobab continues to surprise me. The [previous article](http://christianalfoni.github.io/javascript/2015/02/06/plant-a-baobab-tree-in-your-flux-application.html) I wrote on this used a strategy where you would lock up all your components, but have a dependency to the state tree of the application in each component that needed it. The individual components could point cursors into the state tree, allowing the component to extract state from the state tree and render itself whenever the cursor notified about a change. This optimized the rendering of React JS and gave a very good FLUX structure to your application.\\n\\nWhen going isomorphic though... wait, let me explain what an isomorphic app is before we move on. Typically with a single page application you pass only som basic HTML and script tags on the initial page request. When the page and scripts load, your application starts. You probably have a loader indicating the scripts loading, or if not, just a white screen. This might not seem like such a big problem, but it is. Visitors on your page or application really does not like waiting, not even for a few hundred milliseconds. The google bot collecting page information does not like this either. It requires a complete HTML page to be served when hitting your URL.\\n\\nSo, when going isomorphic, you will actually render your application on the server and deliver it along with your base HTML and script tags. That way the user will instantly see content. React JS is especially elegant in handling this because it will piggy back the existing HTML. What I mean is that when React JS has loaded and you render your application again on the client it will notice that the existing HTML on the page is rendered by React on the server. So instead of doing a normal render, it will just register event listeners etc.\\n\\n### Why change Baobab strategy?\\nWhen loading the application components on the server it will load all the dependencies of each component also. If you are depending on business logic, like some module that changes the state of the tree, that module will probably have its dependencies too. What you end up with is loading your whole client side application on the server, when you only wanted to load the components. This could get you into trouble. There is also a matter of trying to find a way to isolate components to a level where they really are just components.\\n\\n### The current injecting possibilities with React\\nThere are two strategies to injecting state into your application. The first one is using props and the other is using context.\\n\\n#### Props\\n```javascript\\n\\nvar Baobab = require('baobab');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\nvar AppComponent = React.createClass({\\n  render: function () {\\n    return (\\n      <h1>Hello app, you have {this.props.store.items.length} left</h1>\\n    );\\n  }\\n});\\n\\nvar render = function () {\\n  React.render(<AppComponent store={store.get()})/>, document.body);\\n};\\nstore.on('update', render);\\n```\\n\\nOkay, so now we are passing the complete store down to our components and whenever the tree changes, we pass it down again. Since the store shifts references up the tree when a change is done, we can safely use the **PureRenderMixin** on our components. But we have a problem.\\n\\nImagine all the sub components that makes up your app. Most of them will need access to this store object. They can only get that access if their parent passes it down. This pretty much means that all your components has to pass a **store** prop down to its children. That is a lot of work and it couples your components, which is not ideal.\\n\\n#### Context\\nA different strategy is using something called a context. Now, this is not very well documented, but good research is done with [this article](https://www.tildedave.com/2014/11/15/introduction-to-contexts-in-react-js.html). **withContext** is deprecated in favor of using **getChildContext**. Lets have a look at that:\\n\\n```javascript\\n\\nvar Baobab = require('baobab');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\n\\nvar AppComponent = React.createClass({\\n  contextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  render: function () {\\n    return (\\n      <h1>Hello app, you have {this.context.store.items.length} left</h1>\\n    );\\n  }\\n});\\n\\nvar render = function () {\\n  React.render(<WrapperComponent store={store.get()})/>, document.render);\\n};\\nstore.on('update', render);\\n```\\n\\nAs you can see we use a wrapper that sets a context for the application. Any sub component, regardless of their parent, can use the **contextTypes** property and extract the store. That is great! We have removed the need to pass the store down as properties. But we have a problem.\\n\\nIn the [Q&A at react-conf 2015](https://www.youtube.com/watch?v=EPpkboSKvPI&index=20&list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr), around 09:00, there is a question about context. The answer does not flesh out exactly why it is a bad idea, but I think I know why. The problem is two fold, but they are both related to using PureRenderMixin.\\n\\n1. The PureRenderMixin does not check if the values on the context object has changed, making it unable to verify that a render is necessary\\n2. A parent component might not be using the context, but the child does. If the parent uses PureRenderMixin it will not render the child when the context updates\\n\\nA third challenge to mention here, which exists both using **props** and **context**, is that we loose the possbility to just render components that actually needs to update. The store is injected from the top on every change.\\n\\n### So can we get the best of both worlds?\\nI will go through this section showing how this works on the client and server in parallell. Lets get going.\\n\\n#### The injected state\\nWe will not inject the state the same way on the client and the server. On the client we will inject the Baobab tree itself, but on the server we will just inject a plain object. Lets see it in action:\\n\\n*client*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\nvar WrapperComponent = require('./AppWrapper.js');\\n\\nvar store = new Baobab({\\n  items: []\\n}, {\\n  shiftReferences: true\\n});\\n\\n// As you can see we are not using store.get(), but passing the actual store\\nReact.render(<WrapperComponent store={store})/>, document.render);\\n```\\n\\n*server*\\n```javascript\\n\\nvar React = require('react');\\nvar WrapperComponent = require('./app/AppWrapper.js');\\n\\n// We just create a normal object and inject that\\nvar store = {\\n  items: []\\n};\\n\\n// We will see later what we will do with this html\\nvar html = React.renderToString(<WrapperComponent store={store})/>);\\n```\\n\\n#### How the wrapper exposes the context\\nNow, this works exactly the same on the server and client.\\n\\n*WrapperComponent.js*\\n```javascript\\n\\nvar React = require('react');\\nvar AppComponent = require('./AppComponent.js');\\n\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\nmodule.exports = WrapperComponent;\\n```\\n\\nThe wrapper component will expose either the Baobab state tree itself or just a plain object, depending on it being the client or the server.\\n\\n#### A mixin to extract state\\nAs we know from the [existing mixins](https://github.com/Yomguithereal/baobab#react-mixins) for Baobab it is possible to extract state by using a cursors object defined on the component itself. Since we are using the Baobab state tree a bit differently here, we have to create a new mixin. I actually created a [pull request](https://github.com/Yomguithereal/baobab/pull/107) for this. It ended up in a discussion that brings up a different approach. It uses an application event hub to decouple business logic from the components. I encourage you to check it out! But now lets see how we use the mixin on a component\\n\\n*SomeComponent.js (client and server)*\\n```javascript\\n\\nvar React = require('react');\\nvar ContextMixin = require('./ContextMixin.js');\\n\\nvar SomeComponent = React.createClass({\\n  mixins: [ContextMixin],\\n  cursors: {\\n    list: ['admin', 'list']\\n  },\\n  render: function () {\\n  \\n    // Notice we point to the state and not the context\\n    return (\\n      <h1>There are {this.state.list.length} items in this list</h1>\\n    );\\n  }\\n});\\nmodule.exports = SomeComponent;\\n```\\n\\nThe only thing we depend on is the mixin. As the state tree is injected into the context of our application there is no direct dependency to it. The mixin will move the value from the context to the state of the component to allow PureRenderMixin to do its work.\\n\\nAnd now how the mixin actually works:\\n\\n*ContextMixin.js*\\n```javascript\\n\\nvar React = require('react/addons');\\n\\n// We have to know if we are on the client or the server\\nvar isBrowser = !(global && Object.prototype.toString.call(global.process) === '[object process]');\\n\\nvar ContextMixin = {\\n  \\n  // We add the PureRenderMixin for optimized rendering\\n  mixins: [React.addons.PureRenderMixin],\\n  \\n  // We grab the store from the context\\n  contextTypes: {\\n    store: React.PropTypes.object\\n  },\\n  componentWillMount: function () {\\n\\n    if (!this.context || !this.context.store) {\\n      throw new Error('You have to pass a store to you app wrapper');\\n    }\\n    \\n    // If no cursors present, just return\\n    if (!this.cursors) {\\n      return;\\n    }\\n\\n    // Prepare a map of listeners to\\n    // state update\\n    this.subscriptions = {};\\n    \\n    // This is where we create subscriptions to cursors so that\\n    // the component knows about changes\\n    var component = this;\\n    var createSubscription = function (key, cursor) {\\n      return function (value) {\\n        var state = {};\\n        state[key] = cursor.get();\\n        component.setState(state);\\n      };\\n    };\\n\\n    // We go through the cursors\\n    var state = {};\\n    Object.keys(this.cursors).forEach(function (cursorKey) {\\n\\n      // If we are in the browser we move the current state of the\\n      // cursor over to the state object, using the key defined on\\n      // the cursor as the key on our state object. We also register\\n      // a listener for state changes\\n      if (isBrowser) {\\n\\n        var cursor = this.context.store.select(this.cursors[cursorKey]);\\n        var callback = createSubscription(cursorKey, cursor)\\n        state[cursorKey] = cursor.get();\\n        this.subscriptions[cursorKey] = {\\n          cursor: cursor,\\n          callback: callback\\n        };\\n        cursor.on('update', callback);\\n\\n      // If we are on the server we use the same cursor path defined.\\n      // But instead of using the Baobab API, we use the path to drill \\n      // into the state object and set the state\\n      } else {\\n\\n        var path = this.cursors[cursorKey];\\n        var value = path.reduce(function (contextPath, pathKey, index) {\\n          return contextPath[pathKey];\\n        }, this.context.store);\\n        state[cursorKey] = value;\\n\\n      }\\n\\n    }, this);\\n    \\n    // Then we actually put that state on the component\\n    this.setState(state);\\n\\n  },\\n  \\n  // Unregisters listeners of state change\\n  componentWillUnmount: function () {\\n    Object.keys(this.subscriptions).forEach(function (subscription) {\\n      this.subscriptions[subscription].cursor.off('update', subscription.callback);\\n    }, this);\\n  }\\n};\\nmodule.exports = ContextMixin;\\n```\\n\\n### The complete flow\\nNow let us take a look at the complete flow from server to client. We are going to use the jsx file extension as we want to use components on the server too. The benefit of using the jsx extension is that node will only transpile jsx files, not normal js files. Let us first look at the index.html file that we want to load up:\\n\\n*index.html*\\n```javascript\\n\\n<!DOCTYPE html>\\n<html>\\n  <head>\\n    <meta charset=\\\"UTF-8\\\"/>\\n  </head>\\n  <body>\\n    {{APP}}\\n    <script>\\n      window.store = {{STORE}}\\n    </script>\\n    <script src=\\\"app.js\\\"></script>\\n  </body>\\n</html>\\n```\\n\\nWe create a placeholder for where we want to put the HTML of our app. We also put the state we created on the global window object. This allows our client store to grab that state and that way being in sync. We will see this soon.\\n\\n*server.js*\\n```javascript\\n\\n// We make jsx syntax available to node\\nrequire('node-jsx').install({extension: '.jsx'})\\n\\nvar express = require('express');\\nvar fs = require('fs');\\nvar path = require('path');\\nvar React = require('react');\\n\\n// We use a factory as our main server file does not support JSX, \\n// only required files\\nvar AppWrapper = React.createFactory(require('./app/AppWrapper.jsx'));\\n\\n// We fire up an express server\\nvar app = express();\\n\\n// We read the contents of an HTML file we have\\nvar index = fs.readFileSync(path.resolve(__dirname, 'index.html')).toString();\\n\\napp.get('/', function (req, res) {\\n\\n  // First we build up the contents of the store. This could be \\n  // fetching database stuff or whatever\\n  buildStoreContent()\\n    .then(function (store) {\\n    \\n      // We render the application to an HTML string, passing in the store\\n      var app = React.renderToString(AppWrapper({store: store}));\\n      \\n      // We replace our placeholders with both the app html itself and the \\n      // state of the store. You might prefer loading the store state with \\n      // ajax after initial page load in case it is quite large. It is a \\n      // balance you have to decide\\n      var html = index\\n        .replace('{{APP}}', app)\\n        .replace('{{STORE}}', JSON.stringify(store));\\n      \\n      res.type('html');\\n      res.send(html);\\n    });\\n\\n});\\napp.listen(3000);\\n```\\n\\nSo when our client now goes to `localhost:3000` the HTML responded will have the HTML of our app and a store object containing the state it was based upon. The browser will also load up `app.js`. This is a bundled file using either browserify or webpack, so let us look at the main entry file:\\n\\n*main.js (entry point bundled into app.js)*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\n\\n// Coponent uses our ContextMixin\\nvar WrapperComponent = require('./app/WrapperComponent.jsx');\\n\\n// We grab the state from the window\\nvar store = new Baobab(window.store, {\\n  shiftReferences: true\\n});\\n\\nReact.render(<WrapperComponent store={store}/>, document.render);\\n```\\n\\nSo when our `app.js` file launches it will do the exact same thing as the server did, only with a Baobab store instead. The beauty of it is that React JS understands that the current HTML is part of the application. It will basically just wire up the listeners to the store, and do updates when the store has a change. The really cool thing about this is that the components listens to the store completely decoupled from their parent components. This means that the rendering of the application is still as optimized as the strategy explained in the previous article.\\n\\n### Changing the state of the store with actions\\nBut how do we actually go about changing the state of our store from within the components? It would not be a good idea to give each component a dependency to the store, as that is actually what we wanted to avoid. Well, why not use the context? Actions will never be triggered on the server side. They are triggered when the user interacts with the application or some other client module interacts with the store, maybe a websocket service. So how would we do this? Let us extend our wrapper and mixin to also handle actions:\\n\\n*WrapperComponent.jsx*\\n```javascript\\n\\nvar React = require('react');\\nvar WrapperComponent = React.createClass({\\n  childContextTypes: {\\n    store: React.PropTypes.object,\\n    actions: React.PropTypes.object\\n  },\\n  getChildContext: function () {\\n    return {\\n      store: this.props.store,\\n      actions: this.props.actions\\n    };\\n  },\\n  render: function () {\\n    return <AppComponent/>\\n  }\\n});\\nmodule.exports = WrapperComponent;\\n```\\n\\n\\n*ContextMixin*\\n```javascript\\n\\nvar React = require('react/addons');\\nvar isBrowser = !(global && Object.prototype.toString.call(global.process) === '[object process]');\\n\\nvar ContextMixin = {\\n  mixins: [React.addons.PureRenderMixin],\\n  \\n  // Adding actions\\n  contextTypes: {\\n    store: React.PropTypes.object,\\n    actions: React.PropTypes.actions\\n  },\\n  componentWillMount: function () {\\n\\n    if (!this.context || !this.context.store) {\\n      throw new Error('You have to pass a store to you app wrapper');\\n    }\\n    \\n    // We reference the actions on the component itself, to\\n    // shorten the syntax. this.actions, instead of this.context.actions\\n    this.actions = this.context.actions;\\n    \\n    // ... rest of mixin\\n\\n  },\\n  componentWillUnmount: function () { ... }\\n};\\nmodule.exports = ContextMixin;\\n```\\n\\nOkay, so now we are able to pass actions down through our components. We do not have to do any changes on the server, as actions will not be triggered there. But let us pass some actions on our client, looking at our entry point file again:\\n\\n*main.js (entry point bundled into app.js)*\\n```javascript\\n\\nvar React = require('react');\\nvar Baobab = require('baobab');\\nvar WrapperComponent = require('./WrapperComponent.jsx');\\n\\n// Just looking at window.store\\nwindow.store; // { list: [] }\\n\\n// We grab the state from the window\\nvar store = new Baobab(window.store, {\\n  shiftReferences: true\\n});\\n\\n// We create an action to update the store\\nvar actions = {\\n  addItem: function (item) {\\n    store.select('list').push(item);\\n  }\\n};\\n\\n// And we pass those actions down\\nReact.render(<WrapperComponent store={store} actions={actions}/>, document.render);\\n```\\n\\nSo inside our **WrapperComponent** somewhere we have a component that wants to trigger our **addItem** action. Lets imagine:\\n\\n*ListComponent.jsx*\\n```javascript\\n\\nvar React = require('react/addons');\\nvar ContextMixin = require('./ContextMixin.js');\\n\\nvar ListComponent = React.createClass({\\n  mixins: [ContextMixin, React.addons.LinkedStateMixin],\\n  cursors: {\\n  \\n    // We grab the list from the store and put as \\\"list\\\"\\n    // on the components state object. We also listen to\\n    // any changes to this list value\\n    list: ['list']\\n  },\\n  \\n  // We return an initial state for our input that\\n  // will be the interaction of adding a new item to\\n  // the list\\n  getInitialState: function () {\\n    return {\\n      title: ''\\n    };\\n  },\\n  \\n  // We just point to this.actions and run\\n  // the method\\n  addItem: function () {\\n    this.actions.addItem(this.state.title);\\n    this.setState({\\n      title: ''\\n    });\\n  },\\n  renderItem: function (item) {\\n    return <li>{item}</li>\\n  },\\n  render: function () {\\n    return (\\n      <div>\\n        <form onSubmit={this.addItem}>\\n          <input valueLink={this.linkState('title')}/>\\n        </form>\\n        <ul>\\n          {this.state.list.map(this.renderItem)}\\n        </ul>\\n      </div>\\n    );\\n  }\\n});\\n\\nmodule.exports = ListComponent;\\n```\\n\\nAs we can see, using the mixin, we can point to actions on the component itself. This rather than `this.context.actions`. If your application has a lot of actions you could namespace them `this.actions.todos.add`, `this.actions.notifications.fetch` etc.\\n\\n### Summary\\nIn my opinion this is exactly how I want to build my apps. I want to inject state on the server and render the application there, but still allow for highly optimized rendering on the client. I want my components to be as pure as possible and depend on as little as possible. Everything components needs to know about, they know through the context they are running in. \\n\\nI have used this technique on a project I am working on called [EmptyBox](https://github.com/christianalfoni/EmptyBox). It is a hackable blog service using React JS. It also has some other cool features you can not achieve without React JS.\\n\\nTo see a more simple example using this technique you can check out [this repo](https://github.com/christianalfoni/isomorphic-react-baobab-example).\\n\\nPlease feel free to use the mixin documented here or check out the alternative strategy explained in the [pull request](https://github.com/Yomguithereal/baobab/pull/107). Thanks for reading!\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../posts/2015_03_01_True-isomorphic-apps-with-React-and-Baobab.md\n ** module id = 344\n ** module chunks = 10\n **/"],"sourceRoot":""}