{"version":3,"sources":["webpack:///3.blog.js","webpack:///../posts/2015_09_22_Introducing-Cerebral.md"],"names":["webpackJsonp",337,"module","exports"],"mappings":"AAAAA,cAAc,IAERC,IACA,SAASC,EAAQC,GCHvBD,EAAAC,QAAA","file":"3.blog.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 337:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"# Introducing Cerebral\\n\\nHow we think about building web applications evolves quickly. It is not long ago Backbone was the mainstream choice for developing applications. It still is for a lot of developers. But a lot has happened since its release. We got Ember, Angular and the latest mainstream breaker was React with its Flux architecture.\\n\\nAll these projects has made our lives easier. It is practically impossible to build large scale applications in vanilla JavaScript. We need tools. Some frameworks makes up almost all of the tools in your toolbox, while other lets you choose the best tool for the specific job. But frameworks and libraries are not just about the tools, but what the tools build. Do they inspire you to build a spaghetti-labyrinth where you quickly get lost? Or an abstraction-skyscraper where you have to move up and down the floors to understand how things are connected? No matter what your mental image is, you need it. You need to understand the structure of your application. The flow of changes in your application. If you do not know this it is hard to fix bugs and scale.\\n\\n## State and UI\\n\\nWe have two main states in our applications. The UI state and the APP state. The UI state is typically expressed with declarative templates or JSX. But you also have an APP state. This state are all the objects, arrays, strings, numbers and booleans that is used to display the UI. Ideally the UI state is a product of the APP state. This is something all frameworks handles pretty well in practice, though some perform a lot better than others. You create the UI representation by passing a model into a template, using $scopes or passing state to a function that returns virtual DOM. The goal is the same, make UI state a product of your APP state.\\n\\nHow to structure UI state has never been a discussion. It is a tree structure. With children and siblings. How we structure APP state has been a discussion for years though, and still is. Frameworks has a tendency to split application state into different containers with varied degree of abstraction. Like Backbone.Model, $ngResource or flux stores. Often a router also contains some of your application state.\\n\\nI wrote an article on [Baobab](http://www.christianalfoni.com/articles/2015_02_06_Plant-a-Baobab-tree-in-your-flux-application). It is called a state tree. It is a very shallow abstraction because your mental image of this tree is a normal JavaScript object. An object with child objects, arrays and other plain JavaScript values. What makes this so great is that your mental image of UI state and APP state has the same structure. It is a tree! The goal is to produce a UI tree based on the APP state tree.\\n\\nI think it is important to prevent splitting our APP state into many different containers. Each container creates at least one new relationship in your application. And when the relationship (dependency) graph becomes too big we start to loose control of our mental image.\\n\\n## The missing piece\\n\\nBut there is something missing here. How do you make changes to your APP state? What is the mechanism that performs this change? Let us use an example. The user clicks a button. The button should refresh a list of messages. The latest message content should also be downloaded and displayed next to the list.\\n\\nTypically you start with an event listener on the button.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n\\n}\\n```\\n\\nThe big question is, what do you do now? One approach would be to reference the dependency that is responsible for the messages list, Wait for it to complete and then reference the dependency responsible for the current message. The example here uses abstractions from an imagined framework.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n  messages.get(function (messages) {\\n    currentMessage.setByLatestMessage(messages);\\n  });\\n}\\n```\\n\\nThis is an imperative approach where *messages* and *currentMessage* will emit events when they change. This is what updates any UI depending on them. Although the code is readable we know very little of what is actually is going on. By reading this code we do not know what url is being used or what happens on errors. You might say... \\\"I do not care\\\". And yeah, I agree, but only as long as it is working! If this piece of code does not work it can be difficult to reason about why.\\n\\nWe could make this a bit better by taking advantage of Flux.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n  actions.refreshMessages();\\n}\\n```\\n\\n```javascript\\n\\nfunction refreshMessages () {\\n  dispatch(LOADING_MESSAGES, true);\\n  fetch('/messages')\\n    .then(function (messages) {\\n      dispatch(SET_MESSAGES, messages);\\n      dispatch(LOADING_MESSAGES, false);\\n      dispatch(LOADING_MESSAGE, true);    \\n      return fetch('/messages/' + messages[0].id)\\n        .then(function (message) {\\n          dispatch(SET_MESSAGE, message);\\n          dispatch(LOADING_MESSAGE, false);    \\n        })\\n        .catch(function (error) {\\n          dispatch(SET_MESSAGE_ERROR, error);\\n          dispatch(LOADING_MESSAGE, false);  \\n        });\\n    })\\n    .catch(function (error) {\\n      dispatch(SET_MESSAGES_ERROR, error);\\n      dispatch(LOADING_MESSAGES, false);\\n    });\\n}\\n```\\n\\nSo this initially looks a lot worse. And I agree to some extent. Flux is very verbose. But this approach also gives you some advantages. First of all there is no hidden abstractions here. If we read the implementation details we know what is happening. We know the urls, what library does the fetching, explicitly how we manipulate the state of the application and we also see what happens if the intention of state change does not work out. Debugging this function is a lot easier than the previous example.\\n\\nWhat to also notice here is that this function is not a special abstraction from any framework. It is just a normal function. All other state changes in your application will have a function like this. This makes it easier for new developers to understand the project and scale it, as there is only one way to do state changes.\\n\\n## Making it better\\n\\nSo now we have two different approaches to changing the state of our application. We are now going to look at a third option. The project [Cerebral](http://www.christianalfoni.com) is a contribution to making this part of your application simpler. We want an abstraction, but we want it to be shallow. That will keep readability without hiding too many implementation details.\\n\\nBut what if could take this to a whole new level? What if the state changes could be expressed in a developer tool? You could actually see the flow of these state changes? Explore all the data passed through? Even move back and forth in time?\\n\\nTake a look at [this video](https://www.youtube.com/watch?v=j2oxt0-pCuc) and then we will go into what Cerebral is all about.\\n\\n## Cerebral\\n\\nThis is where Cerebral fits into your application:\\n\\n![Cerebral](/images/cerebral-arch.png)\\n\\nIt is the piece between your state tree and the UI. Think of Cerebral as a controller. It is a single entity where you express state changes using **signals**. Your state is a single model entity, a state tree where you hold all the state of your application. When you trigger a signal Cerebral will execute it and notify your UI to update when necessary.\\n\\n### Signals\\n\\nSo one challenge is  having many dependencies, each containing a piece of the application state. The other is having one function with lots of implementation details. Cerebral solves this with signals. A signal does not do anything by itself. A signal is a composition of functions. These functions are called actions. Let us build up the previous example step-by-step using a signal.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages\\n);\\n```\\n\\nA signal needs a name. I encourage you to express that name as: \\\"What happened to trigger the signal\\\". When you look at the signal definition you know what happened to trigger it and what it does.\\n\\n### Actions\\n\\n*setLoadingMessages* is an action. It is just a function. Lets take a look at it:\\n\\n```javascript\\n\\nfunction setLoadingMessages (input, state) {\\n  state.set('isLoadingMessages', true);\\n}\\n```\\n\\nAll actions receives a set of arguments. The first argument is called *input*. The *input* is just an object that is owned by the signal. Any values passed when the signal is triggered is added to this *input*. Any actions outputting values will also be added to this *input*. That means all the actions share this object.\\n\\nThe *state* argument is you API to change the state of your application. It is imperative, meaning you call methods on it. You have different methods to do different mutations. The first argument is always the path. It can be a single string or an array for nested state. You can read more about that on the webpage.\\n\\n### Async actions\\n\\nLet us revisit our signal again and expand.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages,\\n  [\\n    getMessages, {\\n      success: [],\\n      error: []\\n    }\\n  ],\\n  unsetLoadingMessages\\n);\\n```\\n\\nThe array in this signal indicates that the *getMessages* action is asynchronous. We do not define asynchronous behavior in the action itself, but in the signal. This increases your understanding of how the signal runs. We also define an object following *getMessages*. All actions can be followed by an object. The object represents paths. By default any action can choose a *success* or *error* path, but you can also define your own.\\n\\nThe arrays defined on **success** and **error** does not mean actions inside it runs asynchronous. Arrays are also required to express paths. So arrays inside an array means that it is asynchronous. So think of the arguments passed to the signal as an array... which it actually is.\\n\\nLet us take a look at the *getMessages* action.\\n\\n```javascript\\n\\nfunction getMessages (input, state, output) {\\n  fetch('/messages')\\n    .then(function (response) {\\n      return response.toJSON();\\n    })\\n    .then(function (result) {\\n      output.success({result: result});\\n    })\\n    .catch(function (error) {\\n      output.error({error: error.message});\\n    });\\n}\\n```\\n\\nThe *getMessages* action is responsible for getting the messages and outputs the result with *success* or an error with *error*. To actually set the messages we need to create a new action for that.\\n\\n```javascript\\n\\nfunction setMessages (input, state) {\\n  state.set('messages', input.result);\\n}\\n```\\n\\nAs mentioned, any output from an action will be available on the *input* argument. And now our signal looks like this.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages,\\n  [\\n    getMessages, {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  unsetLoadingMessages\\n);\\n```\\n\\n### Factories\\n\\nThere is a concept called factories. It just means \\\"a function returning a function\\\". Lets us see how we can make our code more reusable using a factory.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoading('messages', true),\\n  [\\n    get('/messages'), {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  setLoading('messages', false)\\n);\\n```\\n\\nLet us take a look at *setLoading* first.\\n\\n```javascript\\n\\nfunction setLoading (type, value) {\\n\\n  function action (input, state) {\\n    state.set(['loading', type], value);\\n  }\\n\\n  action.displayName = 'setLoading (' + type + ')';\\n\\n  return action;\\n\\n}\\n```\\n\\nWe have now created our custom tool for setting different loading states in our application. The *displayName* property of an action is used by the debugger. It lets you create dynamic names. This is how the loading state would look in our state tree:\\n\\n```javascript\\n\\n{\\n  loading: {\\n    messages: true,\\n    message: false,\\n    user: false\\n  }\\n}\\n```\\n\\nThis is just one example. You choose the state structure and the factories that best benefits your application. The *get* action would have a similar approach, but the url would be the dynamic part.\\n\\n### Chains\\n\\nThe new ES6 spread operator is a very powerful tool when composing signals. We could express the signal above doing this:\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages\\n);\\n```\\n\\nWhere *getMessages* would just be an array.\\n\\n```javascript\\n\\n[\\n  setLoading('messages', true),\\n  [\\n    get('/messages'), {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  setLoading('messages', false)\\n]\\n```\\n\\nNow, you might say we are starting to hide important information. If you feel that way, do not abstract to this extent. But keep in mind that the debugger will always show you all actions in the chain, no matter how you compose it.\\n\\nLets take it a step further. What if we use a factory to return a chain?\\n\\n```javascript\\n\\nfunction getMessages (outputs) {\\n\\n  outputs = outputs || {};\\n\\n  return [\\n    setLoading('messages', true),\\n    [\\n      get('/messages'), {\\n        success: [setMessages].concat(outputs.success || []),\\n        error: [setMessagesError].concat(outputs.error || [])\\n      }\\n    ],\\n    setLoading('messages', false)\\n  ];\\n\\n}\\n```\\n\\nThis allows us to do:\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [\\n      setLoading('message', true),\\n      [\\n        getLatestMessage, {\\n          success: [setMessage],\\n          error: [setMessageError]\\n        }\\n      ],\\n      setLoading('message', false)\\n    ]\\n  })\\n);\\n```\\n\\nOr we could go all the way and just create a chain for getting the latest message.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [...getLatestMessage]\\n  })\\n);\\n```\\n\\n## The benefits\\n\\nSo this is all fine and dandy, but what benefits do you really get?\\n\\n### Testing\\n\\nFirst of all you get pure functions that are easy to test. None of the functions expressed here calls or references anything outside itself. That means you can fake all the arguments to verify that they run as intended.\\n\\n```javascript\\n\\nvar setLoading = require('./factories/setLoading.js');\\n\\nexports['should change loading state based on type'] = function (test) {\\n  var action = setLoading('messages', true);\\n  var input = {};\\n  var state = {\\n    set: function (path, value) {\\n      test.deepEquals(path, ['loading', 'messages']);\\n      test.equals(value, true);\\n    };\\n  };\\n  action(input, state);\\n  test.done();\\n};\\n```\\n\\nRemember that testing is not only to verify that logic runs as intended. It also protects your from other developers, and yourself, making changes that breaks the application.\\n\\n### Reusability\\n\\nAll actions and chains can be reused across signals. An example of this would be loading the initial messages when opening the messages page.\\n\\n```javascript\\n\\nsignal('messagesOpened',\\n  setTitle('Messages'),\\n  ...getMessages()\\n);\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [...getLatestMessage]\\n  })\\n);\\n```\\n\\nThink of actions like single pieces of lego blocks and chains as multiple lego blocks put together. They can be broken up and put together in any kind of way. This is why we say \\\"composition over inheritance\\\". It gives increadible flexibility.\\n\\n### Debugger\\n\\nThe Cerebral debugger will always display all the actions of a signal. Their inputs, outputs, paths chosen etc. This makes it easy for you to understand what happens inside the application when you are playing around in the UI. You actually get a complete overview of the UI, state changing flow and the current application state. A complete mental image.\\n\\n## Other benefits\\n\\n### Type checking\\n\\nCerebral is able to type check inputs and outputs of actions. It also analyzes all signals and warns you if you are using them wrong. Type checking is important on larger apps and teams. Combine type checking with unit tests for actions and you can feel very safe scaling your app.\\n\\n### Routing\\n\\nThe Cerebral Router has a different approach than most routers. It has nothing to do with your UI at all. You do not reference templates in the router or reference the router inside components. The router is just binding a url to a signal. This allows signals to update the url and urls to trigger signals. To understand how this works you can watch [this video](https://www.youtube.com/watch?v=PZjXPziD9Cw).\\n\\n### Services\\n\\nOften actions needs to use external tools. For example you want to use *superagent* as your ajax library. When you instantate the Cerebral controller you can pass it *services*. These services are the fourth argument in actions.\\n\\n```javascript\\n\\nfunction getSomething (input, state, output, services) {\\n  services.superagent('/something', function (err, result) {\\n\\n  });\\n}\\n```\\n\\nThis allows you to easily mock any external library when you test your actions.\\n\\n## Summary\\n\\nI hope this gave you a good introduction to Cerebral. What it tries to solve, how it solves it and what benefits you get from it. If this was interesting to you I encourage you to go to the [Cerebral website](http://www.christianalfoni.com/cerebral) to read more on how to get going!\\n\"\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** 3.blog.js\n **/","module.exports = \"# Introducing Cerebral\\n\\nHow we think about building web applications evolves quickly. It is not long ago Backbone was the mainstream choice for developing applications. It still is for a lot of developers. But a lot has happened since its release. We got Ember, Angular and the latest mainstream breaker was React with its Flux architecture.\\n\\nAll these projects has made our lives easier. It is practically impossible to build large scale applications in vanilla JavaScript. We need tools. Some frameworks makes up almost all of the tools in your toolbox, while other lets you choose the best tool for the specific job. But frameworks and libraries are not just about the tools, but what the tools build. Do they inspire you to build a spaghetti-labyrinth where you quickly get lost? Or an abstraction-skyscraper where you have to move up and down the floors to understand how things are connected? No matter what your mental image is, you need it. You need to understand the structure of your application. The flow of changes in your application. If you do not know this it is hard to fix bugs and scale.\\n\\n## State and UI\\n\\nWe have two main states in our applications. The UI state and the APP state. The UI state is typically expressed with declarative templates or JSX. But you also have an APP state. This state are all the objects, arrays, strings, numbers and booleans that is used to display the UI. Ideally the UI state is a product of the APP state. This is something all frameworks handles pretty well in practice, though some perform a lot better than others. You create the UI representation by passing a model into a template, using $scopes or passing state to a function that returns virtual DOM. The goal is the same, make UI state a product of your APP state.\\n\\nHow to structure UI state has never been a discussion. It is a tree structure. With children and siblings. How we structure APP state has been a discussion for years though, and still is. Frameworks has a tendency to split application state into different containers with varied degree of abstraction. Like Backbone.Model, $ngResource or flux stores. Often a router also contains some of your application state.\\n\\nI wrote an article on [Baobab](http://www.christianalfoni.com/articles/2015_02_06_Plant-a-Baobab-tree-in-your-flux-application). It is called a state tree. It is a very shallow abstraction because your mental image of this tree is a normal JavaScript object. An object with child objects, arrays and other plain JavaScript values. What makes this so great is that your mental image of UI state and APP state has the same structure. It is a tree! The goal is to produce a UI tree based on the APP state tree.\\n\\nI think it is important to prevent splitting our APP state into many different containers. Each container creates at least one new relationship in your application. And when the relationship (dependency) graph becomes too big we start to loose control of our mental image.\\n\\n## The missing piece\\n\\nBut there is something missing here. How do you make changes to your APP state? What is the mechanism that performs this change? Let us use an example. The user clicks a button. The button should refresh a list of messages. The latest message content should also be downloaded and displayed next to the list.\\n\\nTypically you start with an event listener on the button.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n\\n}\\n```\\n\\nThe big question is, what do you do now? One approach would be to reference the dependency that is responsible for the messages list, Wait for it to complete and then reference the dependency responsible for the current message. The example here uses abstractions from an imagined framework.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n  messages.get(function (messages) {\\n    currentMessage.setByLatestMessage(messages);\\n  });\\n}\\n```\\n\\nThis is an imperative approach where *messages* and *currentMessage* will emit events when they change. This is what updates any UI depending on them. Although the code is readable we know very little of what is actually is going on. By reading this code we do not know what url is being used or what happens on errors. You might say... \\\"I do not care\\\". And yeah, I agree, but only as long as it is working! If this piece of code does not work it can be difficult to reason about why.\\n\\nWe could make this a bit better by taking advantage of Flux.\\n\\n```javascript\\n\\nonButtonClick: function () {\\n  actions.refreshMessages();\\n}\\n```\\n\\n```javascript\\n\\nfunction refreshMessages () {\\n  dispatch(LOADING_MESSAGES, true);\\n  fetch('/messages')\\n    .then(function (messages) {\\n      dispatch(SET_MESSAGES, messages);\\n      dispatch(LOADING_MESSAGES, false);\\n      dispatch(LOADING_MESSAGE, true);    \\n      return fetch('/messages/' + messages[0].id)\\n        .then(function (message) {\\n          dispatch(SET_MESSAGE, message);\\n          dispatch(LOADING_MESSAGE, false);    \\n        })\\n        .catch(function (error) {\\n          dispatch(SET_MESSAGE_ERROR, error);\\n          dispatch(LOADING_MESSAGE, false);  \\n        });\\n    })\\n    .catch(function (error) {\\n      dispatch(SET_MESSAGES_ERROR, error);\\n      dispatch(LOADING_MESSAGES, false);\\n    });\\n}\\n```\\n\\nSo this initially looks a lot worse. And I agree to some extent. Flux is very verbose. But this approach also gives you some advantages. First of all there is no hidden abstractions here. If we read the implementation details we know what is happening. We know the urls, what library does the fetching, explicitly how we manipulate the state of the application and we also see what happens if the intention of state change does not work out. Debugging this function is a lot easier than the previous example.\\n\\nWhat to also notice here is that this function is not a special abstraction from any framework. It is just a normal function. All other state changes in your application will have a function like this. This makes it easier for new developers to understand the project and scale it, as there is only one way to do state changes.\\n\\n## Making it better\\n\\nSo now we have two different approaches to changing the state of our application. We are now going to look at a third option. The project [Cerebral](http://www.christianalfoni.com) is a contribution to making this part of your application simpler. We want an abstraction, but we want it to be shallow. That will keep readability without hiding too many implementation details.\\n\\nBut what if could take this to a whole new level? What if the state changes could be expressed in a developer tool? You could actually see the flow of these state changes? Explore all the data passed through? Even move back and forth in time?\\n\\nTake a look at [this video](https://www.youtube.com/watch?v=j2oxt0-pCuc) and then we will go into what Cerebral is all about.\\n\\n## Cerebral\\n\\nThis is where Cerebral fits into your application:\\n\\n![Cerebral](/images/cerebral-arch.png)\\n\\nIt is the piece between your state tree and the UI. Think of Cerebral as a controller. It is a single entity where you express state changes using **signals**. Your state is a single model entity, a state tree where you hold all the state of your application. When you trigger a signal Cerebral will execute it and notify your UI to update when necessary.\\n\\n### Signals\\n\\nSo one challenge is  having many dependencies, each containing a piece of the application state. The other is having one function with lots of implementation details. Cerebral solves this with signals. A signal does not do anything by itself. A signal is a composition of functions. These functions are called actions. Let us build up the previous example step-by-step using a signal.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages\\n);\\n```\\n\\nA signal needs a name. I encourage you to express that name as: \\\"What happened to trigger the signal\\\". When you look at the signal definition you know what happened to trigger it and what it does.\\n\\n### Actions\\n\\n*setLoadingMessages* is an action. It is just a function. Lets take a look at it:\\n\\n```javascript\\n\\nfunction setLoadingMessages (input, state) {\\n  state.set('isLoadingMessages', true);\\n}\\n```\\n\\nAll actions receives a set of arguments. The first argument is called *input*. The *input* is just an object that is owned by the signal. Any values passed when the signal is triggered is added to this *input*. Any actions outputting values will also be added to this *input*. That means all the actions share this object.\\n\\nThe *state* argument is you API to change the state of your application. It is imperative, meaning you call methods on it. You have different methods to do different mutations. The first argument is always the path. It can be a single string or an array for nested state. You can read more about that on the webpage.\\n\\n### Async actions\\n\\nLet us revisit our signal again and expand.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages,\\n  [\\n    getMessages, {\\n      success: [],\\n      error: []\\n    }\\n  ],\\n  unsetLoadingMessages\\n);\\n```\\n\\nThe array in this signal indicates that the *getMessages* action is asynchronous. We do not define asynchronous behavior in the action itself, but in the signal. This increases your understanding of how the signal runs. We also define an object following *getMessages*. All actions can be followed by an object. The object represents paths. By default any action can choose a *success* or *error* path, but you can also define your own.\\n\\nThe arrays defined on **success** and **error** does not mean actions inside it runs asynchronous. Arrays are also required to express paths. So arrays inside an array means that it is asynchronous. So think of the arguments passed to the signal as an array... which it actually is.\\n\\nLet us take a look at the *getMessages* action.\\n\\n```javascript\\n\\nfunction getMessages (input, state, output) {\\n  fetch('/messages')\\n    .then(function (response) {\\n      return response.toJSON();\\n    })\\n    .then(function (result) {\\n      output.success({result: result});\\n    })\\n    .catch(function (error) {\\n      output.error({error: error.message});\\n    });\\n}\\n```\\n\\nThe *getMessages* action is responsible for getting the messages and outputs the result with *success* or an error with *error*. To actually set the messages we need to create a new action for that.\\n\\n```javascript\\n\\nfunction setMessages (input, state) {\\n  state.set('messages', input.result);\\n}\\n```\\n\\nAs mentioned, any output from an action will be available on the *input* argument. And now our signal looks like this.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoadingMessages,\\n  [\\n    getMessages, {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  unsetLoadingMessages\\n);\\n```\\n\\n### Factories\\n\\nThere is a concept called factories. It just means \\\"a function returning a function\\\". Lets us see how we can make our code more reusable using a factory.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  setLoading('messages', true),\\n  [\\n    get('/messages'), {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  setLoading('messages', false)\\n);\\n```\\n\\nLet us take a look at *setLoading* first.\\n\\n```javascript\\n\\nfunction setLoading (type, value) {\\n\\n  function action (input, state) {\\n    state.set(['loading', type], value);\\n  }\\n\\n  action.displayName = 'setLoading (' + type + ')';\\n\\n  return action;\\n\\n}\\n```\\n\\nWe have now created our custom tool for setting different loading states in our application. The *displayName* property of an action is used by the debugger. It lets you create dynamic names. This is how the loading state would look in our state tree:\\n\\n```javascript\\n\\n{\\n  loading: {\\n    messages: true,\\n    message: false,\\n    user: false\\n  }\\n}\\n```\\n\\nThis is just one example. You choose the state structure and the factories that best benefits your application. The *get* action would have a similar approach, but the url would be the dynamic part.\\n\\n### Chains\\n\\nThe new ES6 spread operator is a very powerful tool when composing signals. We could express the signal above doing this:\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages\\n);\\n```\\n\\nWhere *getMessages* would just be an array.\\n\\n```javascript\\n\\n[\\n  setLoading('messages', true),\\n  [\\n    get('/messages'), {\\n      success: [setMessages],\\n      error: [setMessagesError]\\n    }\\n  ],\\n  setLoading('messages', false)\\n]\\n```\\n\\nNow, you might say we are starting to hide important information. If you feel that way, do not abstract to this extent. But keep in mind that the debugger will always show you all actions in the chain, no matter how you compose it.\\n\\nLets take it a step further. What if we use a factory to return a chain?\\n\\n```javascript\\n\\nfunction getMessages (outputs) {\\n\\n  outputs = outputs || {};\\n\\n  return [\\n    setLoading('messages', true),\\n    [\\n      get('/messages'), {\\n        success: [setMessages].concat(outputs.success || []),\\n        error: [setMessagesError].concat(outputs.error || [])\\n      }\\n    ],\\n    setLoading('messages', false)\\n  ];\\n\\n}\\n```\\n\\nThis allows us to do:\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [\\n      setLoading('message', true),\\n      [\\n        getLatestMessage, {\\n          success: [setMessage],\\n          error: [setMessageError]\\n        }\\n      ],\\n      setLoading('message', false)\\n    ]\\n  })\\n);\\n```\\n\\nOr we could go all the way and just create a chain for getting the latest message.\\n\\n```javascript\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [...getLatestMessage]\\n  })\\n);\\n```\\n\\n## The benefits\\n\\nSo this is all fine and dandy, but what benefits do you really get?\\n\\n### Testing\\n\\nFirst of all you get pure functions that are easy to test. None of the functions expressed here calls or references anything outside itself. That means you can fake all the arguments to verify that they run as intended.\\n\\n```javascript\\n\\nvar setLoading = require('./factories/setLoading.js');\\n\\nexports['should change loading state based on type'] = function (test) {\\n  var action = setLoading('messages', true);\\n  var input = {};\\n  var state = {\\n    set: function (path, value) {\\n      test.deepEquals(path, ['loading', 'messages']);\\n      test.equals(value, true);\\n    };\\n  };\\n  action(input, state);\\n  test.done();\\n};\\n```\\n\\nRemember that testing is not only to verify that logic runs as intended. It also protects your from other developers, and yourself, making changes that breaks the application.\\n\\n### Reusability\\n\\nAll actions and chains can be reused across signals. An example of this would be loading the initial messages when opening the messages page.\\n\\n```javascript\\n\\nsignal('messagesOpened',\\n  setTitle('Messages'),\\n  ...getMessages()\\n);\\n\\nsignal('refreshButtonClicked',\\n  ...getMessages({\\n    success: [...getLatestMessage]\\n  })\\n);\\n```\\n\\nThink of actions like single pieces of lego blocks and chains as multiple lego blocks put together. They can be broken up and put together in any kind of way. This is why we say \\\"composition over inheritance\\\". It gives increadible flexibility.\\n\\n### Debugger\\n\\nThe Cerebral debugger will always display all the actions of a signal. Their inputs, outputs, paths chosen etc. This makes it easy for you to understand what happens inside the application when you are playing around in the UI. You actually get a complete overview of the UI, state changing flow and the current application state. A complete mental image.\\n\\n## Other benefits\\n\\n### Type checking\\n\\nCerebral is able to type check inputs and outputs of actions. It also analyzes all signals and warns you if you are using them wrong. Type checking is important on larger apps and teams. Combine type checking with unit tests for actions and you can feel very safe scaling your app.\\n\\n### Routing\\n\\nThe Cerebral Router has a different approach than most routers. It has nothing to do with your UI at all. You do not reference templates in the router or reference the router inside components. The router is just binding a url to a signal. This allows signals to update the url and urls to trigger signals. To understand how this works you can watch [this video](https://www.youtube.com/watch?v=PZjXPziD9Cw).\\n\\n### Services\\n\\nOften actions needs to use external tools. For example you want to use *superagent* as your ajax library. When you instantate the Cerebral controller you can pass it *services*. These services are the fourth argument in actions.\\n\\n```javascript\\n\\nfunction getSomething (input, state, output, services) {\\n  services.superagent('/something', function (err, result) {\\n\\n  });\\n}\\n```\\n\\nThis allows you to easily mock any external library when you test your actions.\\n\\n## Summary\\n\\nI hope this gave you a good introduction to Cerebral. What it tries to solve, how it solves it and what benefits you get from it. If this was interesting to you I encourage you to go to the [Cerebral website](http://www.christianalfoni.com/cerebral) to read more on how to get going!\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../posts/2015_09_22_Introducing-Cerebral.md\n ** module id = 337\n ** module chunks = 3\n **/"],"sourceRoot":""}